<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Max's Blog]]></title>
  <link href="http://www.mmmmmax.wang/atom.xml" rel="self"/>
  <link href="http://www.mmmmmax.wang/"/>
  <updated>2016-10-11T21:12:15+08:00</updated>
  <id>http://www.mmmmmax.wang/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Auto Layout中的VFL使用教程（译）]]></title>
    <link href="http://www.mmmmmax.wang/14761901397909.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901397909.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2015-12-11 14:12:37</h2>

<p><a href="http://www.raywenderlich.com/110393/auto-layout-visual-format-language-tutorial">原文链接</a></p>

<p>Auto Layout的可视格式化语言（以下简称VFL）允许使用者通过ASCII-art格式化字符串定义约束。<br/>
用一行简单的代码，你可以定义多个水平或垂直方向的约束。对比一个一个加约束，这样可以可以节省很多代码量。<br/>
在这个教程中，你可以用VFL做下面这些事情哦：!</p>

<ul>
<li>构建水平和垂直的约束</li>
<li>在VFL中使用<strong>views</strong>描述</li>
<li>在VFL中使用<strong>metrics</strong></li>
<li>使用<strong>layout options</strong>去关联其他界面元素</li>
<li>使用<strong>layout guides</strong>处理视图的上下边距（译者：比如<strong>UINavigationBar</strong>）</li>
</ul>

<blockquote>
<p><strong>注意：建议读者对Auto Layout有充分了解的情况下阅读此文，如果对于Auto Layout不是很熟悉，建议先阅读<a href="http://www.raywenderlich.com/115440/auto-layout-tutorial-in-ios-9-part-1-getting-started-2">Auto Layout Tutorial Part 1: Getting Started</a>和<a href="http://www.raywenderlich.com/115444/auto-layout-tutorial-in-ios-9-part-2-constraints">Auto Layout Tutorial Part 2: Constraints</a></strong></p>
</blockquote>

<h3 id="toc_1">准备开始吧！</h3>

<p>首先下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Starter.zip">事例工程</a>便于教程使用，该工程提供了一个初级网络社交app-<strong>Grapevine</strong>的基本欢迎页面。在Xcode中运行工程；你将看到如下画面（在模拟器的<strong>Hardware\Rotate Right</strong>中旋转屏幕）:<br/>
<img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Initial-Screen.png" alt="welcomepage"/><br/>
好吧，这个页面真是一团乱，为什么这种情况会发生呢？面对这种情况我们应该怎么做呢？<br/>
当前界面的所有元素都是跟界面的上边缘（top）和左边缘（left）联系的，这是因为它们没有用Auto Layout约束。通过接下来的教程你会让视图看起来更漂亮。<br/>
打开<strong>Main.storyboard</strong>观察界面元素。注意到这些元素都被设置为在编译期移除Auto Layout约束。你不应该在真实项目中这样使用，但是这会让你节省一些元素的初始化时间。<br/>
接下来，打开<strong>ViewController.swift</strong>。在顶部，你可以看到在<strong>Main.storyboard</strong>中跟Interface Builder（IB）视图元素联系的outlet和一些在runtime代替约束的属性。<br/>
这个时候没啥可以说，但是接下来有一大堆跟VFL有关的东西要学！</p>

<h3 id="toc_2">VFL语法</h3>

<p>在你开始编写布局和约束之前，你需要有一些关于VFL格式化串的相关知识。<br/>
第一件要知道的事情：VFL格式化串可以分成如下组成：<br/>
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/07/VisualFormatLanguageOptionsImage.png" alt="formatString"/><br/>
接下来一个一个解释VFL格式化串：</p>

<ol>
<li>约束的方向，非必须。可以有以下的值：

<ul>
<li>H:表示水平方向。</li>
<li>V:表示垂直方向。</li>
<li>不指定:Auto Layout默认水平方向。</li>
</ul></li>
<li>和父视图的头部关联，非必须

<ul>
<li>父视图的上边缘和视图的上边缘的距离（垂直方向）</li>
<li>父视图的头部边缘和视图的头部边缘的距离（水平方向）</li>
</ul></li>
<li>需要布局的视图，必须。</li>
<li>跟另一个视图关联，非必须。<br/></li>
<li>和父视图的尾部关联，非必须。

<ul>
<li>父视图的下边缘和视图的下边缘的距离（垂直方向）</li>
<li>父视图的尾部边缘和视图的尾部边缘的距离（水平方向）</li>
</ul></li>
<li>另外在上图中还有两个特殊的字符，他们的意思是：

<ul>
<li><strong>&quot;?&quot;</strong>代表在格式化串中非必须。</li>
<li><strong>&quot;*&quot;</strong>代表允许在格式化串中出现0次或多次。</li>
</ul></li>
</ol>

<h3 id="toc_3">可使用的符号</h3>

<p>VFL使用一系列符号去描述布局</p>

<ul>
<li><strong>|</strong> 父视图</li>
<li><strong>-</strong> 标准间距(通常8pt；如果这个代表到父视图边缘的间距可以改变)</li>
<li><strong>==</strong> 宽度相等（可被删除）</li>
<li><strong>-20-</strong> 不标准间距（20pt）</li>
<li><strong>&lt;=</strong> 小于等于</li>
<li><strong>&gt;=</strong> 大于等于</li>
<li><strong>@250</strong> 约束权重；可以为0到1000得任意值

<ul>
<li>250 - 低权重</li>
<li>750 - 高权重</li>
<li>1000 - 绝对权重</li>
</ul></li>
</ul>

<h3 id="toc_4">格式化串实例</h3>

<pre><code>  H:|-[icon(==iconDate)]-20-[iconLabel(120@250)]-20@750-[iconDate(&gt;=50)]-|
</code></pre>

<p>接下来一步一步解释这个串：</p>

<ul>
<li>H: 水平方向。</li>
<li>|-[icon icon的头边缘和父视图有一个标准间距。</li>
<li>==iconDate icon的宽度应该和iconDate的宽度相等。</li>
<li>]-20-[iconLabel icon的尾边缘和iconLabel的头边缘有20pt的距离。</li>
<li>[iconLabel(120@250)]iconLabel有一个120pt的宽度，设置成低权重，如果出现冲突Auto Layout会打破这条约束。</li>
<li>-20@750- iconLabel的的尾边缘和iconDate的头边缘有20pt的距离，设置成高权重，如果出现冲突Auto Layout不会打破这条约束。</li>
<li>[iconDate(&gt;=50)] iconDate的宽度应该大于等于50pt。</li>
<li>-| iconDate的尾边缘和父视图的尾边缘有一个标准间距。
<img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/08/got_it.png" alt="good"/>
现在你对VFL已经有了一个基本的认识--接下来就要把这些知识用到实际应用中了。</li>
</ul>

<h3 id="toc_5">创建约束</h3>

<p>Apple在<strong>NSLayoutConstraint</strong>提供了类方法<strong>constraintsWithVisualFormat</strong>去创建约束。你将在<strong>Grapevine</strong>程序化的创建约束</p>

<p>在Xcode中打开<strong>ViewController.swift</strong>，并且添加如下代码到<strong>viewDidLoad()</strong>中：</p>

<pre><code class="language-swift">appImageView.hidden = true
welcomeLabel.hidden = true
summaryLabel.hidden = true
pageControl.hidden = true 
</code></pre>

<p>这些代码会隐藏除了<strong>iconImageView</strong>，<strong>appNameLabel</strong>和<strong>skipButton</strong>之外的元素。运行工程；你会看到如下：<br/>
<img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Hidden-Icons.png" alt="good"/><br/>
棒！你现在已经清除了烦人的元素了，现在在<strong>viewDidLoad()</strong>添加如下代码：</p>

<pre><code class="language-swift">// 1
let views = [&quot;iconImageView&quot;: iconImageView,
  &quot;appNameLabel&quot;: appNameLabel,
  &quot;skipButton&quot;: skipButton]
 
// 2
var allConstraints = [NSLayoutConstraint]()
 
// 3
let iconVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-20-[iconImageView(30)]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += iconVerticalConstraints
 
// 4
let nameLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-23-[appNameLabel]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += nameLabelVerticalConstraints
 
// 5
let skipButtonVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-20-[skipButton]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += skipButtonVerticalConstraints
 
// 6
let topRowHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-15-[iconImageView(30)]-[appNameLabel]-[skipButton]-15-|&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += topRowHorizontalConstraints
 
// 7
NSLayoutConstraint.activateConstraints(allConstraints)
</code></pre>

<p>接下来一步步解释上面的代码：</p>

<ol>
<li>创建一个字典，这个字典用字符串和view对应，用来在格式化串中使用。</li>
<li>创建一个约束数组，你会在接下来的代码中向里面添加约束。</li>
<li>创建<strong>iconImageView</strong>的垂直约束，距父视图的上边缘20pt，本身高度30pt。</li>
<li>创建<strong>appNameLabel</strong>的垂直约束，距父视图的上边缘23pt。</li>
<li>创建<strong>skipButton</strong>的垂直约束，距父视图的上边缘20pt。</li>
<li>设置上面三个元素的水平约束，<strong>iconImageView</strong>的头边缘距父视图的头边缘8pt，宽度30pt。接下来，<strong>iconImageView</strong>的尾边缘距<strong>appNameLabel</strong>头边缘8pt，<strong>appNameLabel</strong>的尾边缘距<strong>skipButton</strong>的头边缘8pt，最后<strong>skipButton</strong>的尾边缘距离父视图的尾边缘15pt。</li>
<li>用<strong>NSLayoutConstraint</strong>的类方法<strong>activateConstraints(_:)</strong>启用约束。在这个步骤你需要添加<strong>allConstraints</strong>数组。</li>
</ol>

<blockquote>
<p><strong>注意：在views字典中的key必须在格式化串中得view串匹配。如果没有，Auto Layout将不能找到引用并且在runtime崩溃。</strong></p>
</blockquote>

<p>运行工程，元素现在看起来怎么样？<br/>
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Horizontal-Layout.png" alt="good"/><br/>
哈哈，看看是不是已经变得好看多了？<br/>
现在把它放着，这不过是个前戏（误）。你还要有一大坨代码要写呢，但是到最后这些都是值得的。<br/>
接下来，你需要给剩下的元素布局，首先，你需要把最开始加到<strong>viewDidLoad()</strong>的代码去掉。不要有怨言，删除下面这些：</p>

<pre><code class="language-swift">    appImageView.hidden = true
    welcomeLabel.hidden = true
    summaryLabel.hidden = true
    pageControl.hidden = true
</code></pre>

<p>这样最开始隐藏的元素就又出现了。<br/>
接下来，把当前的<strong>views</strong>替换成如下的代码：</p>

<pre><code class="language-swift">let views = [&quot;iconImageView&quot;: iconImageView,
 &quot;appNameLabel&quot;: appNameLabel,
 &quot;skipButton&quot;: skipButton,
 &quot;appImageView&quot;: appImageView,
 &quot;welcomeLabel&quot;: welcomeLabel,
 &quot;summaryLabel&quot;: summaryLabel,
 &quot;pageControl&quot;: pageControl]
 ```

现在你已经为**appImageView**，**welcomeLabel**，**summaryLabel**和**pageControl**添加了视图定义，这些都可以在VFL格式化串中使用。
在**activateConstraints()**调用之前，在**viewDidLoad()**中添加如下代码：

```swift
// 1
let summaryHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-15-[summaryLabel]-15-|&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += summaryHorizontalConstraints
 
let welcomeHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-15-[welcomeLabel]-15-|&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += welcomeHorizontalConstraints
 
// 2
let iconToImageVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[iconImageView]-10-[appImageView]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += iconToImageVerticalConstraints
 
// 3
let imageToWelcomeVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[appImageView]-10-[welcomeLabel]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += imageToWelcomeVerticalConstraints
 
// 4
let summaryLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[welcomeLabel]-4-[summaryLabel]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += summaryLabelVerticalConstraints
 
// 5
let summaryToPageVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[summaryLabel]-15-[pageControl(9)]-15-|&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += summaryToPageVerticalConstraints 
</code></pre>

<p>接下来一步步解释上面的代码：</p>

<ol>
<li>创建<strong>summaryLabel</strong>和<strong>welcomeLabel</strong>的水平约束，让它们的头边缘和尾边缘分别距父视图的头边缘和尾边缘15pt。</li>
<li>创建icon和app image的垂直约束，两者距离10pt。</li>
<li>创建app image和welcome label的垂直约束，两者距离10pt。</li>
<li>创建welcome label和summary label的垂直约束，两者距离4pt。</li>
<li>创建summary label和page control的垂直约束，两者相距15pt，并且page control高度为9pt，和父视图的底边缘距离15。</li>
</ol>

<p>运行工程；这些元素看起来怎么样？ <br/>
<img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Layout-Before-Options.png" alt="good"/><br/>
现在看起来还不错了哦。错，其中的一些元素的布局是正确的，然后，有些并没有，image和page control并没有居中！<br/>
<img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/07/No-Center-RageMakger.png" alt="bad"/><br/>
不要害怕，下一节将会告诉你更多关于布局的工具。</p>

<h3 id="toc_6">Layout Options</h3>

<p>Layout Options提供了一个让你在定义约束的时候对视图进行垂线方向上的约束。<br/>
使用<strong>NSLayoutFormatOptions.AlignAllCenterY</strong>是一个使用Layout Options的例子，它可以让view在创建水平约束的时候同时让垂直方向居中。<br/>
如果你不想让水平布局的时候垂直方向都居中，而是边对边的话，那就不应该用这个选项。<br/>
接下来，让我们看看Layout Options在创建约束的时候是多么有用。移除<strong>viewDidLoad()</strong>中如下的代码：</p>

<pre><code class="language-swift">let nameLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-23-[appNameLabel]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += nameLabelVerticalConstraints
 
let skipButtonVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-20-[skipButton]&quot;,
  options: [],
  metrics: nil,
  views: views)
allConstraints += skipButtonVerticalConstraints
</code></pre>

<p>你刚刚移除了<strong>appNameLabel</strong>和<strong>skipButton</strong>的垂直布局。作为替代，你将用Layout Options去给它们添加垂直约束。<br/>
找到创建<strong>topRowHorizontalConstraints</strong>的代码并且设置<strong>options</strong>为<strong>[.AlignAllCenterY]</strong>。看起来是这个样子的：</p>

<pre><code class="language-swift">let topRowHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-15-[iconImageView(30)]-[appNameLabel]-[skipButton]-15-|&quot;,
  options: [.AlignAllCenterY],
  metrics: nil,
  views: views)
</code></pre>

<p>添加<strong>NSLayoutFormatOption .AlignAllCenterY</strong>对上面格式化串中的所有视图都有效，并且创建了一个它们垂直方向中心的约束。如果<strong>iconImageView</strong>提前创建了包含高度的垂直约束也是有效的。因此，<strong>appNameLabel</strong>和<strong>skipButton</strong>同<strong>iconImageView</strong>一样垂直居中。<br/>
如果你现在运行，布局看起来可能没有改变，但是代码变得更棒了。移除创建<strong>welcomeHorizontalConstraints</strong>和将它放进数组的代码。这样就移除了<strong>welcomeLabel</strong>的水平约束。接下来，更新创建<strong>summaryLabelVerticalConstraints</strong>的Layout Options：</p>

<pre><code class="language-swift">summaryLabelVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(&quot;V:[welcomeLabel]-4-[summaryLabel]&quot;,
options: [.AlignAllLeading, .AlignAllTrailing],
metrics: nil,
views: views);
</code></pre>

<p>这个代码增加了<strong>NSLayoutFormatOptions</strong>的<strong>.NSLayoutFormatOptions</strong>和<strong>.AlignAllTrailing</strong>，<strong>welcomeLabel</strong>和<strong>summaryLabel&#39;s</strong>的头边缘和尾边缘会距离它们的父视图的边缘15pt。由于提前为<strong>summaryLabel</strong>定义了水平约束，所以上述代码才会有效。虽然上面的代码带来的是同样的效果，但是实现起来更加优雅了。<br/>
接下来，更新你在创建<strong>summaryToPageVerticalConstraints</strong>时候的选项：</p>

<pre><code class="language-swift">let pageControlVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[summaryLabel]-15-[pageControl(9)]-15-|&quot;,
  options: [.AlignAllCenterX],
  metrics: nil,
  views: views)
</code></pre>

<p>这样就添加了沿x轴中心对齐。同样为<strong>imageToWelcomeVerticalConstraints</strong>添加选项：</p>

<pre><code class="language-swift">let imageToWelcomeVerticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[appImageView]-10-[welcomeLabel]&quot;,
  options: [.AlignAllCenterX],
  metrics: nil,
  views: views)
</code></pre>

<p>运行工程，看看发生了什么？<br/>
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-SublayoutViewHeights.png" alt="perfect"/><br/>
感觉都居中了是吧？Layout Options让你做出了一个更棒的交互界面。</p>

<h3 id="toc_7">NSLayoutFormat选项快速参考</h3>

<p>下面是在<strong>Grapevine</strong>中使用过的属性：</p>

<ul>
<li><strong>.AlignAllCenterX</strong> --使用<strong>NSLayoutAttributeCenterX</strong>的对齐元素</li>
<li><strong>.AlignAllCenterY</strong> --使用<strong>NSLayoutAttributeCenterY</strong>的对齐元素</li>
<li><strong>.AlignAllLeading</strong> --使用<strong>NSLayoutAttributeLeading</strong>的对齐元素</li>
<li><strong>.AlignAllTrailing</strong> --使用<strong>NSLayoutAttributeTrailing</strong>的对齐元素</li>
</ul>

<p>（译者：由于有些种类的文字是从右到左书写的，所以它们的<strong>.AlignAllLeading</strong>等价于<strong>.AlignAllRight</strong>，而对于中文来说，<strong>.AlignAllLeading</strong>等价于<strong>.AlignAllLeft</strong>）</p>

<p>下面是剩余的一些属性：</p>

<ul>
<li><strong>.AlignAllLeft</strong> --使用<strong>NSLayoutAttributeLeft</strong>的对齐元素</li>
<li><strong>.AlignAllRight</strong> --使用<strong>NSLayoutAttributeRight</strong>的对齐元素</li>
<li><strong>.AlignAllTop</strong> --使用<strong>NSLayoutAttributeBottom</strong>的对齐元素</li>
<li><strong>.AlignAllBottom</strong> --使用<strong>NSLayoutAttributeCenterX</strong>的对齐元素</li>
<li><strong>.AlignAllBaseline</strong> --使用<strong>NSLayoutAttributeBaseline</strong>的对齐元素</li>
</ul>

<p>你同样可以在<a href="https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/#//apple_ref/c/tdef/NSLayoutFormatOptions">文档</a>详细查看。</p>

<blockquote>
<p>** 注意：为了让Layout Options有效，至少要有一个元素定义过垂直方向的约束。看下面的例子：**</p>
</blockquote>

<pre><code class="language-swift">   NSLayoutConstraints.constraintsWithVisualFormat(
     &quot;V:[topView]-[middleView]-[bottomView]&quot;,
     options: [.AlignAllLeading],
     metrics: nil,
     views: [&quot;topView&quot;: topView, &quot;middleView&quot;: middleView, &quot;bottomView&quot;:&quot;bottomView&quot;])     
</code></pre>

<blockquote>
<p>** <strong>topView</strong>，<strong>middleView</strong>或者<strong>bottomView</strong>其中一个必须要有一个约束来布局它们的头缘，这样Auto Layout才会正确的产生正确的约束。**</p>
</blockquote>

<p>接下来学习新的概念！<strong>Metrics</strong></p>

<h3 id="toc_8">Metrics</h3>

<p>Metrics是一个能在VFL格式化串中出现的以number为value的字典。如果你需要让距离变得标准化或者有些距离需要计算所以不能直接放在格式化串中的话，Metrics将会变得非常有用！<br/>
将如下常量声明在<strong>ViewController.swift</strong>的变量之上：</p>

<pre><code class="language-swift">// MARK: - Constants
private let horizontalPadding: CGFloat = 15.0
</code></pre>

<p>现在你有了一个用于padding的常量，你可以创建一个metrics字典并且将这个常量使用进去。将如下代码添加到<strong>views</strong>声明的上面：</p>

<pre><code class="language-swift">let metrics = [&quot;hp&quot;: horizontalPadding,
  &quot;iconImageViewWidth&quot;: 30.0]
</code></pre>

<p>上面的代码创建的字典中的key可以再格式化串中使用。<br/>
接下来，用如下代码代替<strong>topRowHorizontalConstraints</strong>和<strong>summaryHorizontalConstraints</strong>的定义：</p>

<pre><code class="language-swift">let horizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-hp-[iconImageView(iconImageViewWidth)]-[appNameLabel]-[skipButton]-hp-|&quot;,
  options: [.AlignAllCenterY],
  metrics: metrics,
  views: views)
 
let summaryHorizontalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;H:|-hp-[summaryLabel]-hp-|&quot;,
  options: [],
  metrics: metrics,
  views: views)
</code></pre>

<p>现在你已经将格式化串中得硬代码用metrics字典中keys代替掉了。<br/>
Auto Layout可以进行串替换，将metrics字典中的value替换到格式化串中的key。所以最终，<strong>hp</strong>将会被替换成15pt，<strong>iconImageViewWidth</strong>将会被替换成30pt。<br/>
你将一个重复出现的莫名其妙的数字变成了一个优雅的变量。如果你想要改变padding，现在就只需要做一件事了。这不是更好吗？metrics字典并不仅限制于常量；如果你需要在runtime期间进行计算，同样可以把这种变量放到metrics中。<br/>
最后的一点小问题是如果你想把这些元素放进<strong>UINavigationController</strong>或者<strong>UITabBarController</strong>中，那该怎么办呢？</p>

<h3 id="toc_9">Layout Guides</h3>

<p>视图控制器有两个可用的Layout Guides：</p>

<ul>
<li>topLayoutGuide</li>
<li>bottomLayoutGuide</li>
</ul>

<p>它们都指定了试图控制器的视图中顶部或者底部导航栏边缘的位置，但是在<strong>Grapevine</strong>中，唯一的导航栏边缘是从状态栏开始的。<br/>
更新<strong>iconVerticalConstraints</strong>的声明代码：</p>

<pre><code class="language-swift">let verticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:|-[iconImageView(30)]&quot;,
  options: [],
  metrics: nil,
  views: views)
</code></pre>

<p>这样你就把状态栏和<strong>iconImageView</strong>之间的20pt的距离移除了，运行代码：<br/>
<img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Without-20pts.png" alt="remove"/><br/>
现在你的状态栏覆盖掉了视图上的一些元素。在横屏模式时，iOS为了给小屏幕设备提供更多的有效空间移除状态栏，这样<strong>iconImageView</strong>会紧靠在屏幕的上方。<br/>
使用<strong>topLayoutGuide</strong>将会解决这种问题，用如下代码代替<strong>views</strong>字典：</p>

<pre><code class="language-swift">  let views: [String: AnyObject] = [&quot;iconImageView&quot;: iconImageView,
    &quot;appNameLabel&quot;: appNameLabel,
    &quot;skipButton&quot;: skipButton,
    &quot;appImageView&quot;: appImageView,
    &quot;welcomeLabel&quot;: welcomeLabel,
    &quot;summaryLabel&quot;: summaryLabel,
    &quot;pageControl&quot;: pageControl,
    &quot;topLayoutGuide&quot;: topLayoutGuide,
    &quot;bottomLayoutGuide&quot;: bottomLayoutGuide]
</code></pre>

<p>这次增加了<strong>topLayoutGuide</strong>和<strong>bottomLayoutGuide</strong>，它们继承自<strong>UILayoutSupport</strong>，比不是<strong>UIView</strong>。<br/>
接下来，就可以使用layout guides去对齐界面元素了。更新<strong>iconVerticalConstraints</strong>的声明：</p>

<pre><code class="language-swift">let verticalConstraints = NSLayoutConstraint.constraintsWithVisualFormat(
  &quot;V:[topLayoutGuide]-[iconImageView(30)]&quot;,
  options: [],
  metrics: nil,
  views: views)
</code></pre>

<p>接下来运行工程，完美！<br/><br/>
<img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Final.png" alt="PERFECT"/><br/>
现在你的顶部的界面元素都依赖着<strong>topLayoutGuide</strong>布局并且无论在横屏或者竖屏模式下状态栏的展现都控制着布局。<br/>
在这一节，你已经学会了当界面存在状态栏的时候如何利用<strong>topLayoutGuide</strong>来控制界面元素的布局。如果你的视图控制器在<strong>UINavigationController</strong>中，<strong>topLayoutGuide</strong>将会包含状态栏和<strong>UINavigationBar</strong>的状态。同时，如果你的试图控制器在<strong>UITabBarController</strong>中，<strong>bottomLayoutGuide</strong>将会提供底部边缘的状态。</p>

<h3 id="toc_10">限制</h3>

<p>VFL让你用一行代码写出了多个约束，大大降低了手指的负担。但是对于当前的实现，还存在一些限制；还有一些重要的东西需要理解。</p>

<ul>
<li>视图中心</li>
<li>使用约束中的Multiplier</li>
</ul>

<h4 id="toc_11">视图中心</h4>

<p>在<strong>Grapevine</strong>中，你用了<strong>.AlignAllCenterY</strong>和<strong>.AlignAllCenterX</strong>。<br/>
使用这些表示你让一些视图和其他的一些视图的垂直中心或者水平中心对齐，然而只有在这些视图中存在已经有足够约束能够确定它们的水平和垂直中心位置的时候才能变得有效。<br/>
即使现在通过VFL你可以用一些小把戏来处理中心视图，但是这也不保证在将来的版本中依然有效。<br/>
<img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/08/constraints_constraining.png" alt="CONSTRAIN"/></p>

<h4 id="toc_12">使用约束中的Multiplier</h4>

<p>通过Multiplier，你可以通过比例来对视图进行布局，比如你可以让一个label的宽度是它父视图的60%。由于VFL会同时创建多个没有名字的约束，所以不能通过格式化串来设置百分比系数。</p>

<blockquote>
<p>** 注意：你可以通过<strong>constraintsWithVisualFormat</strong>返回的数组来遍历约束，但是你需要去确定它们的<strong>NSLayoutAttribute</strong>属性，这样才能正确的设定Multiplier，但即使是这样，你依然需要替换这些约束，因为约束的Multiplier是不可变的。**</p>
</blockquote>

<h3 id="toc_13">现在要干什么？</h3>

<p>你可以下载完整的<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/09/Grapevine-Final.zip">工程</a>。</p>

<blockquote>
<p>** 注意：如果你有多个工程使用相同的bundle id，Xcode可能会出现问题。所以如果你完成了这个教程并且想最后运行一下刚才下载的工程，你可以使用<strong>shift+option+command+K</strong>清空一下build目录。**</p>
</blockquote>

<p>现在你已经知道VFL如何工作啦，你已经可以在你的界面中使用这种布局咯。<br/>
你已经知道了如何使用layout options 来减少需要定义的约束。你也已经知道如何使用metrics来在runtime定义距离而不仅仅是编译期。最后，你也知道了VFL的一些限制，但是利大于弊，你应该好好的利用它。<br/>
如果你对该教程或者Auto Layout有什么问题或者建议的话，请留言！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB阅读笔记（一）]]></title>
    <link href="http://www.mmmmmax.wang/14761901397970.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901397970.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2016-01-22 17:30:23</h2>

<h2 id="toc_1">FMDatabaseQueue</h2>

<p>该类提供了多线程操作数据库的功能。尽量不要在多线程操作同一个<strong>FMDatabase</strong>实例。取而代之的是在每一个<strong>FMDatabaseQueue</strong>创建一个<strong>FMDatabase</strong>实例。下面来详细看代码吧。</p>

<pre><code class="language-objectivec">- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags {
    
    self = [super init];
    
    if (self != nil) {
        
        _db = [[[self class] databaseClass] databaseWithPath:aPath];
        FMDBRetain(_db);
        
#if SQLITE_VERSION_NUMBER &gt;= 3005000
        BOOL success = [_db openWithFlags:openFlags];
#else
        BOOL success = [_db open];
#endif
        if (!success) {
            NSLog(@&quot;Could not create database queue for path %@&quot;, aPath);
            FMDBRelease(self);
            return 0x00;
        }
        
        _path = FMDBReturnRetained(aPath);
        
        _queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);
        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);
        _openFlags = openFlags;
    }
    
    return self;
}
</code></pre>

<p>初始化方法，创建database实例，然后创建了一个串行队列，并用<strong>dispatch_queue_set_specific</strong>方法跟<strong>FMDatabaseQueue</strong>创建关联。<strong>openWithFlags:openFlags</strong>为开启文件的选项。默认<strong>open</strong>方法的选项为<strong>SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE</strong>。</p>

<pre><code class="language-objectivec">- (void)inDatabase:(void (^)(FMDatabase *db))block {
    /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue
     * and then check it against self to make sure we&#39;re not about to deadlock. */
    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);
    assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);
    
    FMDBRetain(self);
    
    dispatch_sync(_queue, ^() {
        
        FMDatabase *db = [self database];
        block(db);
        
        if ([db hasOpenResultSets]) {
            NSLog(@&quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&quot;);
            
#if defined(DEBUG) &amp;&amp; DEBUG
            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&quot;_openResultSets&quot;] copy]);
            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) {
                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];
                NSLog(@&quot;query: &#39;%@&#39;&quot;, [rs query]);
            }
#endif
        }
    });
    
    FMDBRelease(self);
}
</code></pre>

<p>利用<strong>dispatch_get_specific</strong>获得<strong>FMDatabaseQueue</strong>关联的线程，如果是同一个线程，则直接断言，因为同线程执行<strong>dispatch_sync</strong>会造成死锁。这里的<strong>FMDBRetain(self)</strong>和<strong>FMDBRelease(self)</strong>应该是为了防止block内提前将self释放造成后续访问野指针。接下来在关联线程中获取database并执行block，这里如果在database中存在多个查询结果则防处警告，debug模式下会打印出这些查询结果的query。这里的copy操作不理解。</p>

<pre><code class="language-objectivec">- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block;
- (void)inDeferredTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block;
</code></pre>

<p>这两个方法的内部逻辑很简单，判断事务开启<strong>defer transaction</strong> 或者<strong>exclusive transaction</strong>，关闭时根据业务逻辑<strong>rollback</strong>或者<strong>commit</strong>。这个类很简单，就分析到这里。</p>

<h3 id="toc_2">FMDatabasePool</h3>

<p>一开篇就强调不到万不得已不要用这个类，如果你只是用来读数据库，可以用这个类，否则可能造成死锁。</p>

<pre><code class="language-objectivec">- (void)executeLocked:(void (^)(void))aBlock {
    dispatch_sync(_lockQueue, aBlock);
}
</code></pre>

<p>该类通过上述方法保证池子操作的线程安全（毕竟已经同步单线程跑了），但是该类并不能保证池内数据库操作安全，该死锁还是会死锁，同时读写会引发很大的问题。这个类没有什么太多值得说的地方，如果有大量并发读操作的需求的话推荐使用这个类，其他都不推荐。</p>

<h3 id="toc_3">FMResultSet</h3>

<p>query结果的类。通过<strong>FMStatement</strong>访问结果。这个类主要的功能算是提供了一套友好的OC接口来访问结果。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB阅读笔记（二）]]></title>
    <link href="http://www.mmmmmax.wang/14761901398013.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901398013.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2016-01-26 19:36:11</h2>

<h3 id="toc_1">FMDatabase</h3>

<p><strong>FMDatabase</strong>作为核心类，封装了sqlite的大部分数据库操作。<br/>
初始化方法没什么可说的，从**- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName;<br/>
**说起。</p>

<pre><code class="language-objectivec">- (BOOL)openWithFlags:(int)flags vfs:(NSString *)vfsName;
</code></pre>

<h4 id="toc_2">flags</h4>

<p>三个必选项：<strong>SQLITE_OPEN_READONLY</strong>，<strong>SQLITE_OPEN_READWRITE</strong>，<strong>SQLITE_OPEN_CREATE</strong></p>

<p><a href="http://www.sqlite.org/vfs.html">vfs</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS二维码扫描识别]]></title>
    <link href="http://www.mmmmmax.wang/14761901398063.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901398063.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2015-12-23 12:35:36</h2>

<h3 id="toc_1">前言</h3>

<p>二维码功能在app中很常用，在iOS7之前iOS的二维码功能通常用<strong>ZXing</strong>等框架完成。iOS7之后<strong>AVFoundation</strong>已经支持了原生的二维码扫描功能。这篇文章帮助大家在app中实现此功能，并且会详细的解释一下其中的过程。在开始编码之前，先介绍一下相关的概念。</p>

<h3 id="toc_2">概念相关</h3>

<h4 id="toc_3">AVCaptureSession</h4>

<p>熟悉<strong>AVFoundation</strong>的同学都会知道<strong>AVCaptureSession</strong>是其中的核心类。<strong>AVCaptureSession</strong>协调了一个物理设备的输入（input）和输出（output）。</p>

<h4 id="toc_4">AVCaptureInput</h4>

<p>顾名思义，就是上文中<strong>AVCaptureSession</strong>协调的输入。不过<strong>AVCaptureInput</strong>是一个虚类不能直接实例化，可以使用其子类。<strong>AVCaptureInput</strong>有多个接口可以同时承载一种或多种媒体数据，比如可以同时承载音频数据流和视频数据流。本文章使用的输入是<strong>AVCaptureInput</strong>的子类<strong>AVCaptureDeviceInput</strong>。<strong>AVCaptureDeviceInput</strong>提供了利用<strong>AVCaptureDevice</strong>捕捉流媒体的功能，顾名思义，就是利用这个输入就可以捕捉到二维码并且识别。</p>

<h4 id="toc_5">AVCaptureDevice</h4>

<p>物理设备的一个抽象，具体到设备上比如摄像头，麦克风。</p>

<h4 id="toc_6">AVCaptureOutput</h4>

<p>跟<strong>AVCaptureInput</strong>相同也是抽象基类，比如说我们看到的视频，听到的音频都是通过它处理输出。<strong>AVCaptureInput</strong>可以持有一个或多个<strong>AVCaptureConnection</strong>实例。本文章使用的是其子类<strong>AVCaptureMetadataOutput</strong>，该类可以捕获从输出中获取的元数据（metadata）。</p>

<h4 id="toc_7">AVCaptureConnection</h4>

<p>本文中没有使用到，但是还是简单介绍一下概念。<strong>AVCaptureConnection</strong>可以将<strong>AVCaptureInputPort</strong>和<strong>AVCaptureOutput</strong>或者<strong>AVCaptureVideoPreviewLayer</strong>关联起来。本文不需要手动调用这些关联，当利用<strong>AVCaptureSession</strong>关联输入和输出的时候，这些关联就已经生成。</p>

<h3 id="toc_8">开始</h3>

<p>首先看一下接口文件</p>

<pre><code class="language-objectivec">@protocol  QRCodeParserDelegate&lt;NSObject&gt;

@required

- (void)QRCodeParser:(AVMetadataMachineReadableCodeObject *)object;

@end

typedef NS_ENUM(NSInteger, QRCodeParserStatus) {
    QRCodeParserStatusPrepare  = 1,
    QRCodeParserStatusScanning = 2,
    QRCodeParserStatusStop     = 3
};

@interface QRCodeParser : NSObject

@property (nonatomic, assign)QRCodeParserStatus status;

- (instancetype)initWithFrame:(CGRect)rect
                  andDelegate:(UIViewController&lt;QRCodeParserDelegate&gt;*)delegate;
- (void)stopReading;
- (void)startReading;
- (BOOL)initQRScanner;

@end
</code></pre>

<ul>
<li><strong>QRCodeParserDelegate</strong>作为识别出二维码的回调。</li>
<li><strong>QRCodeParserStatus</strong>parser的状态机，本文没有使用到。</li>
<li><strong>initWithFrame:andDelegate:</strong>为parser的初始化方法。</li>
<li><strong>startReading</strong>开始扫描。</li>
<li><strong>stopReading</strong>停止扫描。</li>
<li><strong>initQRScanner</strong>初始化二维码扫描器</li>
</ul>

<p>以下是核心部分代码：</p>

<pre><code class="language-objectivec">- (BOOL)initQRScanner{
    NSError *error = nil;
    
    //1
    AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    //2
    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice
                                                                        error:&amp;error];
    if (!input || error) {
        NSLog(@&quot;%@&quot;, [error localizedDescription]);
        return NO;
    }
    //3
    _captureSession = [AVCaptureSession new];
    [_captureSession addInput:input];
    SafeRelease(input);
    
    //4
    _captureMetadataOutput = [AVCaptureMetadataOutput new];
    [_captureMetadataOutput setRectOfInterest:CGRectMake(0.25, 0.25, 0.5, 0.5)];
    [_captureSession addOutput:_captureMetadataOutput];
    
    //5
    dispatchQueue = dispatch_queue_create(&quot;QRQueue&quot;, NULL);
    [_captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue];
    [_captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]];
    
    //6
    _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession];
    [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];
    [_videoPreviewLayer setFrame:_rect];
    [_ownerVC.view.layer addSublayer:_videoPreviewLayer];
    
    //7
    [_captureSession startRunning];
    
    return YES;
    
}
</code></pre>

<p>接下来一步步解释上述代码：</p>

<ol>
<li>初始化捕捉设备，并且该设备类型为视频设备<strong>AVMediaTypeVideo</strong></li>
<li>利用<strong>captureDevice</strong>生成输入源<strong>AVCaptureDeviceInput</strong>，从而此输入源交给<strong>AVCaptureSession</strong>来协调处理。</li>
<li>初始化<strong>_captureSession</strong>协调输入输出，并将输入源<strong>input</strong>赋值。</li>
<li>生成输出源<strong>_captureMetadataOutput</strong>，并将它付给<strong>AVCaptureSession</strong>，<strong>rectOfInterest</strong>表示将输出源可识别的范围控制在一个方形中。</li>
<li>注册一个线程，并在该线程中设置<strong>_captureMetadataOutput</strong>代理为<strong>self</strong>。</li>
<li>初始化<strong>_videoPreviewLayer</strong>来承载<strong>input</strong>提供的画面，并将其加在目标视图上。</li>
</ol>

<p>接下来实现其<strong>startReading</strong>，<strong>stopReading</strong>方法：</p>

<pre><code class="language-Objective-c">- (void)startReading{
    [_captureSession startRunning];
}

-(void)stopReading{
    [_captureSession stopRunning];
}
</code></pre>

<p>扫描二维码之后的回调：</p>

<pre><code class="language-objectivec">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection{
    for (AVMetadataObject *object in metadataObjects) {
        if ([[object type] isEqualToString:AVMetadataObjectTypeQRCode]
            &amp;&amp; [object isKindOfClass:[AVMetadataMachineReadableCodeObject class]]) {
            [self stopReading];
            if ([_ownerVC respondsToSelector:@selector(QRCodeParser:)]) {
                [_ownerVC performSelector:@selector(QRCodeParser:)
                                 onThread:[NSThread mainThread]
                               withObject:object
                            waitUntilDone:YES];
            }
        }
    }
}
</code></pre>

<p>需要注意的是该回调触发在后台线程，如果有处理UI相关的操作请在主线程。<br/>
接下来是有关根据二维码图片读取内容和根据内容生成二维码的代码截取：</p>

<pre><code class="language-objectivec">@implementation UIImage (QRCodeGenerator)

- (NSString *)QRCodeParserToContent{
    CIContext *context = [CIContext contextWithOptions:nil];
    CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode
                                              context:context
                                              options:@{CIDetectorAccuracy:CIDetectorAccuracyHigh}];
    NSMutableString *result = [NSMutableString new];
    CIImage *ciImage = [CIImage imageWithCGImage:self.CGImage];
    NSArray *features = [detector featuresInImage:ciImage];
    if ([features count] &gt; 0) {
        for (CIQRCodeFeature *feature in features) {
            [result appendString:feature.messageString];
        }
    }else{
        result = nil;
    }
    return result;
}

+ (UIImage *)createQRForString:(NSString *)qrString
                     imageSize:(CGSize)imageSize {
    NSData *stringData = [qrString dataUsingEncoding:NSUTF8StringEncoding];
    CIFilter *qrFilter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;];
    [qrFilter setDefaults];
    [qrFilter setValue:stringData forKey:@&quot;inputMessage&quot;];
    [qrFilter setValue:@&quot;M&quot; forKey:@&quot;inputCorrectionLevel&quot;];
    
    CIImage *outPutCIImage = qrFilter.outputImage;

    CGImageRef imageRef = [[CIContext contextWithOptions:nil] createCGImage:outPutCIImage
                                                                   fromRect:outPutCIImage.extent];
    CGSize size = CGSizeMake(outPutCIImage.extent.size.width,
                             outPutCIImage.extent.size.height);
    
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(size.width * 10.0,
                                                      size.height * 10.0),
                                           NO,
                                           1.0);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetInterpolationQuality(context, kCGInterpolationNone);
    CGContextSetAllowsAntialiasing(context, YES);
    CGAffineTransform trans = CGAffineTransformMakeTranslation(0.0, size.height * 10.0);
    trans = CGAffineTransformScale(trans, 10.0, -10.0);
    CGContextConcatCTM(context, trans);
    CGContextDrawImage(context, CGRectMake(0, 0, size.width, size.height), imageRef);
    
    UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    return result;
}
@end
</code></pre>

<p>接下来解释一下上面的代码：<br/>
<strong>QRCodeParserToContent</strong>方法中，首先创建一个用来渲染<strong>CIImage</strong>的上下文<strong>context</strong>，值得注意的是<strong>CIContext</strong>线程安全，<strong>CIFilter</strong>非安全。然后创建一个<strong>detector</strong>用来探测image中得元素，用来获取一个图片中的<strong>CIFeature</strong>数组，这里<strong>CIDetectorTypeQRCode</strong>表示<strong>detector</strong>需要探测的元素为二维码。接下来的代码简洁明了，获取图片中的<strong>CIFeature</strong>，并将其中的<strong>messageString</strong>拼接返回。<br/>
<strong>这个方法最低支持到iOS8.0</strong></p>

<p><strong>createQRForString:imageSize:</strong>方法中，利用的核心类是<strong>CIFilter</strong>，这个<strong>CIFilter</strong>可以看做是一个滤镜，核心的思路是交给<strong>filter</strong>一个输入，也就是原图片，然后配置<strong>filter</strong>的属性，最后获取的<strong>outputImage</strong>就是加完滤镜的图片。方法中的<strong>imageRef</strong>就是结果图片。最后利用<strong>CoreGraphics</strong>中的绘制图片的函数绘制出<strong>UIImage</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《征服C指针》阅读笔记 II]]></title>
    <link href="http://www.mmmmmax.wang/14761901398114.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901398114.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2015-12-31 11:39:59</h2>

<h3 id="toc_1">第三章 揭秘C的语法</h3>

<h4 id="toc_2">3.1 解读C的声明</h4>

<p>这张首先介绍的是如何读C中的声明，让你用英文的语法去理解声明，可能是岛国人民的英语比较烂，声明这里我感觉没那么多坑，容易晕的地方无非就是指针数组和数组指针，简而言之就是** * <strong>和</strong>变量名<strong>如果有小括号返回的就是指针，否则就是数组。这个问题归根结底就是</strong> * <strong>的优先级高，就拿</strong>int <em>p[10]</em><em>来说，</em>* * <strong>的优先级很高，跟int结合后就决定了返回的是</strong>int *<strong>而读到最后发现</strong>[]<strong>，自然而然就变成了</strong>返回int * 类型的数组<strong>，而如果</strong>int *<strong>加上小括号变成</strong>int (<em>p)[]</em><em>，首先返回的会是</em><em>int</em><em>,看到</em><em>[]</em><em>就知道返回的是</em><em>int数组</em><em>,最后</em><em>(</em>p)<strong>声明</strong>p**是指针，最终返回的是数组指针，这里个人感觉不要揣测Dennis Ritchie的想法，记住就好，熟而生巧。</p>

<h4 id="toc_3">3.2 C的数据类型的模型</h4>

<p>前半段介绍了一下数组指针的小细节。如下代码：</p>

<pre><code class="language-c"> int arr[10];
 int *p = &amp;arr;
 printf(&quot;size ------- \n arr - %d\n &amp;arr - %d\n p - %d\n&quot;,sizeof(arr), sizeof(&amp;arr), sizeof(p));
 printf(&quot;point ------- \n arr - %p\n &amp;arr - %p\n p - %p\n&quot;,arr, &amp;arr, p);
</code></pre>

<p>输出结果为</p>

<pre><code class="language-c">size ------- 
 arr - 40
 &amp;arr - 8
 p - 8
point ------- 
 arr - 0x7fff5fbff830
 &amp;arr - 0x7fff5fbff830
 p - 0x7fff5fbff830
</code></pre>

<p>可以看到最大的差别就是p和[arr]的sizeof不同，影响的地方就是两种类型的指针作自增操作的时候数值不同，两者的运用场景各有不同。这里差别来自于<strong>p</strong>是**int *<strong>类型而arr是</strong>int [10]**类型的，编译器会根据不同的类型做自增操作。</p>

<p><strong>C中不存在多维数组，只不过是数组的数组</strong></p>

<p>3.2.6介绍了函数指针，总结起来：</p>

<ol>
<li>从函数类型不能派生出除了指针类型之外的其他任何类型。（原因在于函数类型的大小是不定的，但是函数指针的大小是确定的）</li>
<li>从数组类型是不能派生出函数类型的。</li>
</ol>

<p>3.2.10不完全类型，总结起来：<br/>
C有三种类型：</p>

<ol>
<li>对象类型（char、int、数组、指针、结构体）</li>
<li>函数类型</li>
<li>不完全类型，结构体标记的声明就是不完全类型(void 也为不完全类型)</li>
</ol>

<p>例子：typedef struct Woman_tag Woman;声明的时候并不知道Woman的大小。<br/>
<strong>结构体中不能存在不完全类型，但是可以存在不完全类型的指针</strong></p>

<h4 id="toc_4">3.3表达式</h4>

<p>略</p>

<h4 id="toc_5">3.4解读C的声明</h4>

<p>3.4.1介绍了<strong>const</strong>修饰符，总结：<br/>
跟以前的认识一样，<strong>const</strong>修饰它右面整体的类型</p>

<p>3.5介绍了C声明函数的参数不可以有数组，只能传递数组指针，并且重要的是<strong>int a[]</strong>和<strong>int *a</strong>等价，但是个人推荐前一种方式，因为前一种更加直观。然后作者倾向于后一种，不解。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《征服C指针》阅读笔记]]></title>
    <link href="http://www.mmmmmax.wang/14761901398161.html"/>
    <updated>2016-10-11T20:48:59+08:00</updated>
    <id>http://www.mmmmmax.wang/14761901398161.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">2015-12-28 14:42:11</h2>

<h4 id="toc_1">缘由</h4>

<p>上个周末参加了SF的分享会，听了一位来自QQ浏览器的工程师关于iOS内存管理的分享。当初认为iOS上的内存管理不重要，也不会出多大的篓子，基本概念比如引用计数什么的明白原理就好。然而听分享的时候还是云里雾里大概只能听懂70%，回去之后反思了一下，大学时候的c学的就很烂，都是只是会用，如果想精进就必须要明白其中的原理，《征服C指针》这本书以前就听说过，很多同学推荐过，不过大概是大学期间确实玩心太重，不能耐下心来去看这种既不能提高绩点，又不能和当时实习挂钩的书（当年实习的大型机真是荒废了半年多的时光啊）。想那么多，不如现在就开始做，这篇读书笔记一是为了分享，也是为了督促自己。目测会有好几篇。那就开始吧！</p>

<h3 id="toc_2">第一章 从基础开始</h3>

<h4 id="toc_3">1.1 什么是C</h4>

<p>这一节主要介绍了c的由来，我以前一直以为<strong>sizeof</strong>只是一个函数，没想到竟然是关键字。太菜了，惭愧惭愧。</p>

<h4 id="toc_4">1.2 关于指针</h4>

<p>不得不说，即使是基础介绍的一章，也涨了姿势。<br/>
这里有指针<strong>a</strong></p>

<ol>
<li>如果<strong>a</strong>保存了其他变量的地址，可以说是<strong>a</strong>指向该地址。</li>
<li>*<strong>a</strong>等同于<strong>a</strong>指向的变量。</li>
</ol>

<p>疑问：</p>

<pre><code class="language-c">    int a = 5;
    void *b = &amp;a;
    b++;
    printf(&quot;%p\n&quot;,&amp;a);
    printf(&quot;%lu\n&quot;,sizeof(int));
    printf(&quot;%p\n&quot;,(int *)b);
</code></pre>

<p>我运行上面代码的时候地址加1并没有加4？why？<br/>
结论：因为我声明的无类型指针，系统不知道自加的时候要加多少。</p>

<h4 id="toc_5">1.3 关于数组</h4>

<ol>
<li><strong>p[i]</strong>只是*<strong>(p + i)</strong>的简写。这个结论真是涨姿势了。<strong>[]</strong>只是一个语法糖而已。</li>
<li>使用指针的效率并不会更高。</li>
<li>对数组进行值传递的时候，将数组整体整理成结构体成员。</li>
</ol>

<h3 id="toc_6">第二章 C是怎么使用内存的</h3>

<h4 id="toc_7">2.1 虚拟地址</h4>

<p>要点：程序面对的都是虚拟地址空间（这些结论已经有一定了解了）</p>

<h4 id="toc_8">2.2 内存的使用方法</h4>

<ol>
<li>全局变量：定义在函数外面的变量都为全局变量</li>
<li><strong>static</strong>：除去声明为静态变量外，全局变量加上<strong>static</strong> 后限定作用域在源代码文件中。</li>
<li>局部变量声明在函数中。</li>
</ol>

]]></content>
  </entry>
  
</feed>
