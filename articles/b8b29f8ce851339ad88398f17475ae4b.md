# 《征服C指针》阅读笔记 II

### 第三章 揭秘C的语法
#### 3.1 解读C的声明
这张首先介绍的是如何读C中的声明，让你用英文的语法去理解声明，可能是岛国人民的英语比较烂，声明这里我感觉没那么多坑，容易晕的地方无非就是指针数组和数组指针，简而言之就是** * **和**变量名**如果有小括号返回的就是指针，否则就是数组。这个问题归根结底就是** * **的优先级高，就拿**int *p[10]**来说，** * **的优先级很高，跟int结合后就决定了返回的是**int ***而读到最后发现**[]**，自然而然就变成了**返回int * 类型的数组**，而如果**int ***加上小括号变成**int (*p)[]**，首先返回的会是**int**,看到**[]**就知道返回的是**int数组**,最后**(*p)**声明**p**是指针，最终返回的是数组指针，这里个人感觉不要揣测Dennis Ritchie的想法，记住就好，熟而生巧。

#### 3.2 C的数据类型的模型
前半段介绍了一下数组指针的小细节。如下代码：

```c
 int arr[10];
 int *p = &arr;
 printf("size ------- \n arr - %d\n &arr - %d\n p - %d\n",sizeof(arr), sizeof(&arr), sizeof(p));
 printf("point ------- \n arr - %p\n &arr - %p\n p - %p\n",arr, &arr, p);
```

输出结果为

```c    
size ------- 
 arr - 40
 &arr - 8
 p - 8
point ------- 
 arr - 0x7fff5fbff830
 &arr - 0x7fff5fbff830
 p - 0x7fff5fbff830
```
可以看到最大的差别就是p和[arr]的sizeof不同，影响的地方就是两种类型的指针作自增操作的时候数值不同，两者的运用场景各有不同。这里差别来自于**p**是**int ***类型而arr是**int [10]**类型的，编译器会根据不同的类型做自增操作。

**C中不存在多维数组，只不过是数组的数组**

3.2.6介绍了函数指针，总结起来：

1. 从函数类型不能派生出除了指针类型之外的其他任何类型。（原因在于函数类型的大小是不定的，但是函数指针的大小是确定的）
2. 从数组类型是不能派生出函数类型的。

3.2.10不完全类型，总结起来：
C有三种类型：

1. 对象类型（char、int、数组、指针、结构体）
2. 函数类型
3. 不完全类型，结构体标记的声明就是不完全类型(void 也为不完全类型)

例子：typedef struct Woman_tag Woman;声明的时候并不知道Woman的大小。
**结构体中不能存在不完全类型，但是可以存在不完全类型的指针**

#### 3.3表达式
略

#### 3.4解读C的声明
3.4.1介绍了**const**修饰符，总结：
跟以前的认识一样，**const**修饰它右面整体的类型

3.5介绍了C声明函数的参数不可以有数组，只能传递数组指针，并且重要的是**int a[]**和**int *a**等价，但是个人推荐前一种方式，因为前一种更加直观。然后作者倾向于后一种，不解。

